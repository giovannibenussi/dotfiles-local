noremap <Leader>w :update<CR>
noremap <Leader>q :quit<CR>

set tags^=./.git/tags;
"colorscheme night-owl
colorscheme one
set background=dark
let g:airline_theme='one'
highlight SpellCap cterm=underline ctermfg=black ctermbg=yellow
highlight SpellBad cterm=underline ctermfg=red ctermbg=NONE

" Split panes shortcuts
map <Leader><Leader>- :sp<Esc>
map <Leader><Leader>\ :vsp<Esc>

let g:winresizer_start_key = '<Leader>e'
let g:winresizer_vert_resize = 2
let g:winresizer_horiz_resize = 2

let g:UltiSnipsExpandTrigger="<c-l>"
let g:UltiSnipsJumpForwardTrigger="<c-m>"
let g:UltiSnipsJumpBackwardTrigger="<c-n>"

nnoremap <Leader>s<Leader> :b#<CR>
nnoremap <Leader><Leader>d :bd<CR>

nnoremap <leader>fr :VtrFocusRunner<cr>
nnoremap <leader>fc :VtrFlushCommand<cr>
nnoremap <leader>sf :VtrSendFile<cr>
nnoremap <leader>m :VtrSendCommandToRunner<cr>
nnoremap <leader>vap :VtrAttachToPane<cr>
nnoremap <leader>or :VtrOpenRunner<cr>
nnoremap <leader>sl :VtrSendLinesToRunner<cr>
vnoremap <leader>sl :VtrSendLinesToRunner<cr>

nnoremap <C-t>     :tabnew<CR>

nnoremap \ :Ag<SPACE>
nmap <silent> <C-f> :Ag "<cword>" <CR>

"let g:VtrUseVtrMaps = 1
nnoremap <leader>c :VtrSendCtrlC<cr>

" Align GitHub-flavored Markdown tables
au FileType markdown vmap <Leader><Bslash> :EasyAlign*<Bar><Enter>
ino <C-A> <C-O>yiW<End>=<C-R>=<C-R>0<CR>

" Allow to switch between buffers without having to save them and don't loose changes
set hidden

let g:user_emmet_leader_key='<C-k>'
let g:user_emmet_settings = {
\  'javascript.jsx' : {
\      'extends': 'jsx',
\      'quote_char': "'",
\  },
\}

highlight Pmenu ctermfg=white ctermbg=black
highlight PmenuSel ctermfg=white ctermbg=darkblue

let g:rspec_command = "call VtrSendCommand('bundle exec spring rspec {spec}')"

" vim-rspec mappings
"map <Leader>t :call RunCurrentSpecFile()<CR>
"map <Leader>s :call RunNearestSpec()<CR>
"map <Leader>l :call RunLastSpec()<CR>
"map <Leader>a :call RunAllSpecs()<CR>

nnoremap <C-c> :VtrSendKeysRaw ^C<cr>

"let g:prettier#autoformat = 0
"autocmd BufWritePre *.js,*.jsx,*.mjs,*.ts,*.tsx,*.css,*.less,*.scss,*.json,*.graphql,*.md,*.vue,*.yaml,*.html PrettierAsync
"command! EnablePrettier autocmd BufRead,BufWritePre *.js,*.jsx,*.mjs,*.ts,*.tsx,*.css,*.less,*.scss,*.json,*.graphql,*.md,*.vue,*.yaml,*.html,*.javascript.jsx,*.typescript.tsx PrettierAsync

"let g:prettier#exec_cmd_path = "/usr/local/bin/prettier_d"
let g:prettier#quickfix_enabled = 0

nmap <CR> o<Esc>k
nmap d<CR> O<Esc>j
nmap a<CR> kdd
nmap s<CR> jddk

" https://vim.fandom.com/wiki/Copy_filename_to_clipboard
" Convert slashes to backslashes for Windows.
" https://stackoverflow.com/questions/916875/yank-file-name-path-of-current-buffer-in-vim

" Relative file path
nmap <Leader>fm :let @*=expand("%")<CR> 
" Absolute file path
nmap <Leader>ffm :let @*=expand("%:p")<CR>
" File name
nmap <Leader>fn :let @*=expand("%:t")<CR>
" File folder path
nmap <Leader>fp :let @*=expand("%:p:h").'/'<CR>


nnoremap <leader>ntf :NERDTreeFind<cr>
map <C-m> :NERDTreeToggle<CR>
nnoremap <C-n> :NERDTree<CR>

nnoremap <C-S-tab> :tabprevious<CR>
nnoremap <C-tab>   :tabnext<CR>
nnoremap <C-t>     :tabnew<CR>

" Paste yanked line without line breaks before/after cursor position
nnoremap gP i<CR><Esc>PkJxJx
nnoremap gp a<CR><Esc>PkJxJx
nnoremap <leader>fw i onClick={(e) => console.log('onClick')}<Esc>
nnoremap <leader>fe i onClick={onClick}<Esc>bb
nnoremap <leader>y "*y
nnoremap <leader>yy "*yy
"nnoremap <leader><leader>f UltiSnipsAddFiletypes tsx.javascript.js
"au BufRead,BufNewFile *.tsx set filetype=javascript.jsx

" <Leader>f{char} to move to {char}
map  <Leader><Leader>s <Plug>(easymotion-bd-f)
nmap <Leader><Leader>s <Plug>(easymotion-overwin-f)

" s{char}{char} to move to {char}{char}
nmap <Leader><Leader>r <Plug>(easymotion-overwin-f2)

" Move to line
map <Leader><Leader>l <Plug>(easymotion-bd-jk)
nmap <Leader><Leader>l <Plug>(easymotion-overwin-line)

" Move to word
"map  <Leader><Leader>f <Plug>(easymotion-bd-w)
"nmap <Leader><Leader>f <Plug>(easymotion-overwin-w)

let g:EasyMotion_keys = "abcdefghijklmnopqrstuvwxy"

nmap <silent> gd <Plug>(coc-definition)
nmap <silent> gy <Plug>(coc-type-definition)
nmap <silent> gi <Plug>(coc-implementation)
nmap <silent> gr <Plug>(coc-references)

"let g:airline_section_b = '(branch)'
"let g:airline_section_z = 'hello %l bye'

syntax enable
filetype plugin indent on
let g:rustfmt_autosave = 1

set statusline+=%#warningmsg#
set statusline+=%{SyntasticStatuslineFlag()}
set statusline+=%*

let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 1
let g:syntastic_check_on_open = 1
let g:syntastic_check_on_wq = 0

map <Leader>l <Plug>(easymotion-lineforward)
map <Leader>j <Plug>(easymotion-j)
map <Leader>k <Plug>(easymotion-k)
map <Leader>h <Plug>(easymotion-linebackward)

"let g:EasyMotion_startofline = 0

nnoremap <leader>u kmtjddgg}O<Esc>P`tzz10<<

" https://www.codeography.com/2013/06/19/navigating-vim-and-tmux-splits
if exists('$TMUX')
  function! TmuxOrSplitSwitch(wincmd, tmuxdir)
    let previous_winnr = winnr()
    silent! execute "wincmd " . a:wincmd
    if previous_winnr == winnr()
      call system("tmux select-pane -" . a:tmuxdir)
      redraw!
    endif
  endfunction

  let previous_title = substitute(system("tmux display-message -p '#{pane_title}'"), '\n', '', '')
  let &t_ti = "\<Esc>]2;vim\<Esc>\\" . &t_ti
  let &t_te = "\<Esc>]2;". previous_title . "\<Esc>\\" . &t_te

  nnoremap <silent> <C-h> :call TmuxOrSplitSwitch('h', 'L')<cr>
  nnoremap <silent> <C-j> :call TmuxOrSplitSwitch('j', 'D')<cr>
  nnoremap <silent> <C-k> :call TmuxOrSplitSwitch('k', 'U')<cr>
  nnoremap <silent> <C-l> :call TmuxOrSplitSwitch('l', 'R')<cr>
else
  map <C-h> <C-w>h
  map <C-j> <C-w>j
  map <C-k> <C-w>k
  map <C-l> <C-w>l
endif

" https://vim.fandom.com/wiki/Moving_lines_up_or_down#Move_command
nnoremap <Leader><Leader>j :m .+1<CR>==
nnoremap <Leader><Leader>k :m .-2<CR>==
inoremap <Leader><Leader>j <Esc>:m .+1<CR>==gi
inoremap <Leader><Leader>k <Esc>:m .-2<CR>==gi
vnoremap <Leader><Leader>j :m '>+1<CR>gv=gv
vnoremap <Leader><Leader>k :m '<-2<CR>gv=gv

let g:fzf_preview_window = []

let g:airline_section_b = ''
let g:airline_section_z= '%#__accent_bold#%l%#__restore__#%#__accent_bold#/%L | %#__restore__#%#__accent_bold#%v%#__restore__#'
"let g:airline_section_z= '%#__accent_bold#%l%#__restore__#%#__accent_bold#/%L%{g:airline_symbols.maxlinenr}%#__restore__#%#__accent_bold#%{g:airline_symbols.colnr}%v%#__restore__#'
"let g:airline_section_z= '%p%%%#__accent_bold#%{g:airline_symbols.linenr}%l%#__restore__#%#__accent_bold#/%L%{g:airline_symbols.maxlinenr}%#__restore__#%#__accent_bold#%{g:airline_symbols.colnr}%v%#__restore__#'

nnoremap <leader><leader>a GVgg
nnoremap <leader><leader>sa mmGVgg :VtrSendLinesToRunner<cr>`mzz

" Map GitHub Copilot to ctrl-j
"imap <silent><script><expr> <C-J> copilot#Accept("\<CR>")
"imap <silent><script><expr> <C-M> <Plug>(copilot-next)
"imap <C-m> <Plug>(copilot-next)
"imap <C-,> <Plug>(copilot-previous)
"imap <C-m> <Plug>(copilot-next)
"imap <C-,> <Plug>(copilot-previous)
"let g:copilot_no_tab_map = v:true
"imap <C-M> <Plug>(copilot-next)
"imap <C-,> <Plug>(copilot-previous)

set nohlsearch

" ===== COC Config =====
inoremap <silent><expr> <TAB>
      \ pumvisible() ? "\<C-n>" :
      \ CheckBackspace() ? "\<TAB>" :
      \ coc#refresh()
inoremap <expr><S-TAB> pumvisible() ? "\<C-p>" : "\<C-h>"

function! CheckBackspace() abort
  let col = col('.') - 1
  return !col || getline('.')[col - 1]  =~# '\s'
endfunction

inoremap <silent><expr> <cr> pumvisible() ? coc#_select_confirm()
                              \: "\<C-g>u\<CR>\<c-r>=coc#on_enter()\<CR>"

set cmdheight=2

nmap <silent> <Leader>i <Plug>(coc-definition)
nmap <silent> gy <Plug>(coc-type-definition)
nmap <silent> gi <Plug>(coc-implementation)
nmap <silent> gr <Plug>(coc-references)

nmap <silent> <Leader><Leader>m <Plug>(coc-diagnostic-prev)
nmap <silent> <Leader><Leader>n <Plug>(coc-diagnostic-next)

"nmap <silent> gm <Plug>(coc-diagnostic-prev)
"nmap <silent> gn <Plug>(coc-diagnostic-next)

nmap <leader>rn <Plug>(coc-rename)

autocmd bufnewfile,bufread *.tsx set filetype=typescriptreact
autocmd bufnewfile,bufread *.jsx set filetype=javascript.jsx
" ===== COC Config =====

let g:csstoinline_no_mapping = 1
let g:csstoinline_wrap_pixels = 1
nmap <leader>ti <Plug>ToInlineN
xmap <leader>ti <Plug>ToInlineV
nmap <leader>fi <Plug>FromInlineN
xmap <leader>fi <Plug>FromInlineV

" Use K to show documentation in preview window
nnoremap <silent> K :call <SID>show_documentation()<CR>

function! s:show_documentation()
  if (index(['vim','help'], &filetype) >= 0)
    execute 'h '.expand('<cword>')
  else
    call CocAction('doHover')
  endif
endfunction

command! -nargs=0 Prettier :CocCommand prettier.forceFormatDocument

" disable CoC by default
autocmd VimEnter * exe "CocDisable" 
" enable CoC when entering vim to Rust file
"autocmd VimEnter *.ts exe "CocEnable" 
" enable CoC when switching buffer to Rust file
"autocmd BufEnter *.rs exe "CocEnable" 
" disable CoC when exiting Rust file buffer
"autocmd BufLeave *.rs exe "CocDisable"

noremap <Leader>p :Prettier<CR>

function! ToggleTestAutoGroup()
    if !exists('#TestAutoGroup#BufWritePre')
        augroup TestAutoGroup
            autocmd!
            autocmd BufWritePre *.js,*.jsx,*.mjs,*.ts,*.tsx,*.css,*.less,*.scss,*.json,*.graphql,*.md,*.vue,*.yaml,*.html Prettier
            echom "Prettier Enabled"
        augroup END
    else
        augroup TestAutoGroup
            autocmd!
            echom "Prettier Disabled"
        augroup END
    endif
endfunction

nnoremap <Leader><Leader>p :call ToggleTestAutoGroup()<CR>

" Fix issue with syntax highlighting on long files.
" https://github.com/neovim/neovim/issues/12274#issuecomment-625853056
syntax sync fromstart

" Applying codeAction to the selected region.
" Example: `<leader>aap` for current paragraph
"xmap <leader>a  <Plug>(coc-codeaction-selected)
"nmap <leader>a  <Plug>(coc-codeaction-selected)
nmap <leader>a v<Plug>(coc-codeaction-selected)

" Remap keys for applying codeAction to the current buffer.
nmap <leader>ac  <Plug>(coc-codeaction)
" Apply AutoFix to problem on the current line.
nmap <leader>qf  <Plug>(coc-fix-current)

" Run the Code Lens action on the current line.
nmap <leader>al  <Plug>(coc-codelens-action)

" Map function and class text objects
" NOTE: Requires 'textDocument.documentSymbol' support from the language server.
xmap if <Plug>(coc-funcobj-i)
omap if <Plug>(coc-funcobj-i)
xmap af <Plug>(coc-funcobj-a)
omap af <Plug>(coc-funcobj-a)
xmap ic <Plug>(coc-classobj-i)
omap ic <Plug>(coc-classobj-i)
xmap ac <Plug>(coc-classobj-a)
omap ac <Plug>(coc-classobj-a)
